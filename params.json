{
  "name": "amdr.js",
  "tagline": "JavaScript: Asynchronous Module Define & Require",
  "body": "# AMDR (Asynchronous Module Define & Require)\r\namdr.js is a small and very fast AMD-compliant asynchronous loader.<br>\r\nSize: less than 10KB (>5KB gzipped) using UglifyJS.\r\n\r\n----------------------------------------\r\n\r\n## Features:\r\n* Loads [CommonJS AMD-formatted javascript modules][1] in parallel.\r\n* Loads [CommonJS Modules][2] (wrapped in a `define()`)\r\n* Loads non-AMD javascript files in parallel, too.\r\n* Supports IE6+, FireFox, Chrome, Safari 3.2+, Opera 9.5+\r\n* Tested with IE6+, FireFox 2+, Chrome 10+, Safari 4+, Opera 9.5+\r\n\r\n\r\n## Basic API:\r\n* `define([name String], [dependencies Array], factory Function)`\r\n* `require(dependencies Array|String[, callback Function[, fallback Function]])`\r\n* `require.config([config Object])`\r\n\r\n\r\n## Config:\r\n* `config.config` - config object for module\r\n* `config.timeout` - number of loading timeout in second (default is `7`)\r\n* `config.debug` - boolean of amdr.js debug state (default is `false`)\r\n* `config.urlBase` - string of base path (ex. '/path/to/base')\r\n* `config.urlArgs` - string of request parameter(s) to be appended (ex. 'key1=value1&key2=value2')\r\n* `config.urlExt` - string of default file extension (default is `'.js'`)\r\n* `config.pathMap` - object of path mappings for module names not found directly under baseUrl.\r\n  The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a \"/\" or has a URL protocol in it (\"like http:\").\r\n\r\n### Example:\r\n    require.config({\r\n      timeout: 15,\r\n      urlBase: '/another/path',\r\n      pathMap: {\r\n        'foo': '../bar/'\r\n      }\r\n    });\r\n    require(['foo/module', 'my/module', 'a.js', 'b.js'],\r\n      function(fooModule, myModule) {\r\n          //This function will be called when all the dependencies\r\n          //listed above are loaded. Note that this function could\r\n          //be called before the page is loaded.\r\n          //This callback is optional.\r\n      }\r\n    );\r\n\r\n\r\n## CommonJS Modules:\r\n* `require(path String[, callback Function[, fallback Function]])` require other module under current module's context\r\n* `exports` module exports object\r\n* `module` module object\r\n  * `module.exports` - object same as the `exports` module\r\n  * `module.config()` - returns \"config\" property form the global config\r\n  * `module.toUrl(path String[, config Object])` - converts a module name to the url by current module's context or the given config\r\n\r\n\r\n## Circular Dependency\r\nUse `require` module inside of a module to load a dynamic module.\r\nThis may help to solve some circular dependency issues.\r\n\r\n----------------------------------------\r\n\r\n## Built-in Module \"Promise\" API:\r\n\r\n`Promise(then Function)` is a abstract class of [Promise/A][3].\r\n\r\nThe promise represents the *eventual outcome*, which is either fulfillment (success) and an associated value, or rejection (failure) and an associated *reason*.\r\nThe promise provides mechanisms for arranging to call a function on its value or reason, and produces a new promise for the result.\r\n\r\n### Instance methods:\r\n* `promise.then(callback Function[, fallback Function[, progback Function]])`\r\n  * `callback` to be called with the value after `promise` is fulfilled, or\r\n  * `fallback` to be called with the rejection reason after `promise` is rejected.\r\n  * `progback` to be called with any progress updates issued by `promise`.\r\n* `promise.always(alwaysBack Function)`\r\n  * `alwaysBack` to be called with the value after `promise` is fulfilled, or with the rejection reason after `promise` is rejected.\r\n\r\n### Static methods: (implements Promise/A)\r\n* `Promise.resolve(promiseOrValue *)`\r\n* `Promise.resolved([value *])`\r\n* `Promise.rejected([reason *])`\r\n* `Promise.when(promiseOrValue *[, callback Function[, fallback Function[, progback Function]]])`\r\n  * If `promiseOrValue` is a value, arranges for `callback` to be called with that value, and returns a promise for the result.\r\n  * If `promiseOrValue` is a promise, arranges for\r\n    * `callback` to be called with the value after `promise` is fulfilled, or\r\n    * `fallback` to be called with the rejection reason after `promise` is rejected.\r\n    * `progback` to be called with any progress updates issued by `promise`.\r\n\r\n\r\n## Built-in Module \"Deferred\" API:\r\n\r\n`Deferred()` is a class, implements [Promise/A][3].\r\n\r\nA deferred represents an operation whose resolution is *pending*.\r\nIt has separate `promise` and `resolver` parts that can be *safely* given out to separate groups of consumers and producers, respectively, to allow safe, one-way communication.\r\n\r\n### Instance properties:\r\n* `deferred.promise` a Promise instance (implemented [Promise/A][3]).\r\n\r\n### Instance methods:\r\n* `deferred.resolve([value *])` resolve promise.\r\n* `deferred.reject([reason *])` reject promise.\r\n* `deferred.notify([info *])` fires progbacks.\r\n* `deferred.state()` returns \"padding\", \"resolved\" or \"rejected\"\r\n* `deferred.then([callback Function[, fallback Function[, progback Function]]])`.\r\n  * `callback` to be called with the value after `promise` is fulfilled, or\r\n  * `fallback` to be called with the rejection reason after `promise` is rejected.\r\n  * `progback` to be called with any progress updates issued by `promise`.\r\n\r\n----------------------------------------\r\n\r\n## Loader Module \"css\":\r\nThis is the css file loader.\r\n* Usage: `require(['css!path/of/style.css']);`\r\n* Export: `<link>` element of the `style.css`.\r\n\r\n\r\n## Loader Module \"has\":\r\nThis is the conditional module loader.\r\n* Usage: `require(['has!condition?module-a:module-b']);`\r\n* Export: condition matched module exports.\r\n* API:\r\n  * `has(feature String) Boolean`\r\n  * `has.add(feature String, definition Boolean|Function)`\r\n\r\n\r\n## Loader Module \"hot\":\r\nThis is the hot module loader.\r\nNo different between uses `hot` loader and normal way in the first time.\r\nAfter `hot.unload()` be called, only recalls the module factory in next time, will not reload resource.\r\n* Usage: `require(['hot!module-c']);`\r\n* Export: target module exports.\r\n* API:\r\n  * `hot.unload()` - cleans all hot modules exports.\r\n\r\n----------------------------------------\r\n\r\n## License\r\nThis project is released under MIT license.\r\n\r\n\r\n[1]: http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\t\"AMD Module\"\r\n[2]: http://wiki.commonjs.org/wiki/Modules/1.1\t\"CommonJS Module\"\r\n[3]: http://wiki.commonjs.org/wiki/Promises/A\t\"Promise/A\"\r\n",
  "google": " UA-35375054-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}